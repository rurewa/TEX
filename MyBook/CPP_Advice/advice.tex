\documentclass[a4paper,16pt]{report} % Формат А4 и размер шрифта
\usepackage{cmap} % поиск в PDF
\usepackage[T2A]{fontenc} % кодировка
\usepackage[utf8]{inputenc} % кодировка исходного кода
\usepackage[english,russian]{babel} % локализаци и переносы
\usepackage{verbatim} % для длинных комментариев
\usepackage{array}
\usepackage{listings} % для вставки кода cpp
%opening
\title{Советы и правила по программированию C++}
\date{\today} % текущая дата
\author{Александр Изотов}

\begin{document}
	\maketitle % создаёт титульный лист

\begin{abstract} % аннотация
Сделано по книге Ravesli
\end{abstract}
%\clearpage % новая страница
\begin{center} % Заголовок
	\large\textbf{Объявление и и инициализация переменных}
\end{center}

\textbf{Правило:} Если у вас изначально имеется значение для переменной – используйте инициализацию, вместо присваивания.

\textit{Хорошей практикой считается всегда инициализировать свои переменные. Это будет гарантией того, что ваша переменная всегда имеет одно и то же значение и вы не получите ошибку от компилятора.}

\textbf{Правило:} Убедитесь, что все ваши переменные в программе имеют значения (либо через инициализацию, либо через операцию присваивания).
\\
\begin{center} 
	\large\textbf{Функции}
\end{center}

\begin{itemize} % Перечисление
	\item[1] Код, который появляется более одного раза в программе, лучше переписать в виде функции. Например, если мы получаем данные от пользователя несколько раз одним и тем же способом, то это отличный вариант для написания отдельной функции.
	\item[2] Код, который используется для сортировки чего-либо, лучше записать в виде отдельной функции. Например, если у нас есть список вещей, которые нужно отсортировать - пишем функцию сортировки, куда передаём несортированный список и откуда получаем отсортированный.
	\item[3] Функция должна выполнять одно (и только одно) задание.
	Когда функция становится слишком большой, сложной или непонятной – её следует разбить на несколько подфункций. Это называется рефакторинг кода.
\end{itemize}


\textbf{Правило:} Имена, которые используются внутри функции (включая
параметры), доступны/видны только внутри этой же функции.

\textbf{Идентификатор} — это имя переменной, функции, класса или другого объекта в C++. Мы можем определять идентификаторы любыми словами/именами. Тем не менее, есть несколько общих правил, которые необходимо соблюдать:

\begin{itemize}
	\item[1]Идентификатор не может быть ключевым словом. Ключевые слова зарезервированы.
	\item[2]Идентификатор может состоять только из букв (нижнего или верхнего регистра), цифр или символов подчёркивания. Это означает, что все другие символы и пробелы - запрещены.
	\item[3]Идентификатор должен начинаться с буквы (нижнего или верхнего регистра). Он не может начинаться с цифры.
	\item[4]C++ различает нижний регистр от верхнего. nvalue отличается от nValue и отличается от NVALUE.
\end{itemize}

Если вы работаете с чужим кодом, то хорошей практикой будет придерживаться стиля, в котором написан этот код, даже если он не соответствует рекомендациям выше.

\begin{itemize}
	\item[*] не начинайте ваши имена с символа подчёркивания, так как такие имена уже зарезервированы для ОС, библиотеки и/или используются компилятором.
	\item[*] используйте в качестве идентификаторов только те имена, которые реально описывают то, чем является объект. Очень характерно для неопытных программистов сокращать имена переменных, дабы сэкономить время при наборе кода или потому что они думают, что всё и так понятно. В большинстве случаев не всё всегда является понятным и очевидным. В идеале переменные нужно называть так, чтобы человек, который первый раз увидел ваш код, понял, как можно скорее, что этот код делает. Через 3 месяца, когда вы будете пересматривать свои программы, вы забудете, как они работают, и будете благодарны самому себе за то, что называли переменные по сути, а не как попало. Чем сложнее код, тем проще и понятнее должны быть идентификаторы.
\end{itemize}
% Таблица
\begin{tabular}{ | l | c | >{\raggedright\arraybackslash}p{5,5cm}| } % настроки столбцов таблицы
	\hline
	int ccount & Плохо & Никто не знает, что такое ccount  \\ \hline % новая строка таблицы
	int customerCount & Хорошо & Теперь понятно, что мы считаем \\ \hline
	int i & Плохо* & В большинстве нетривиальных случаев - плохо, 
	простых примерах - может быть (например, в циклах) \\ \hline
	int index & 50/50 & Хорошо, если очевидно, индексом чего является переменная\\ \hline
	int totalScore & Хорошо & Всё понятно \\ \hline
	int \_count & Плохо & Не начинайте имена переменных с символов подчёркивания\\ \hline
	int count & 50/50 & Хорошо, если очевидно, что мы считаем \\ \hline
	int data & Плохо & Какой тип данных? \\ \hline
	int value1, value2 & 50/50 & Может быть трудно понять разницу между переменными \\ \hline
	int numberOfApples & Хорошо & Всё понятно \\ \hline
	int monstersKilled & Хорошо & Всё понятно \\ \hline
	int int x, y & Плохо* & В большинстве нетривиальных случаев - плохо, 
	в простых примерах - может быть (например, в математических функциях) \\ \hline
\end{tabular}
\\
\\ % начинают новую стоку без начала нового абзаца
\begin{sloppypar} % Абзац
*Примечание: Можно использовать тривиальные имена для переменных,
которые имеют тривиальное использование (например, для переменных в
цикле, в простых математических функциях и т.д.).
\end{sloppypar}
\begin{sloppypar}
\textbf{Литерал} - это фиксированное значение, которое записывается непосредственно в исходном коде (например: 7 или 3,14159). \textbf{Литералы}, переменные и функции ещё известны как \textit{операнды}.
\end{sloppypar}

\begin{sloppypar}
\textbf{Операнды} - это данные, с которыми работает выражение. \textbf{Литералы} имеют фиксированные значения, переменным можно присваивать значения, функции же производят определённые значения (в зависимости от типа возврата, исключение: функции типа void).
\end{sloppypar}

\textbf{Операторы.}
Последним пазлом в выражениях являются \textbf{операторы}. С их помощью мы можем объединить операнды для получения нового значения. Например, в выражении "5 \textit{+} 2", \textit{+} является оператором. С помощью + мы объединили операнды 5 и 2 для получения нового значения (7).
\\
\begin{sloppypar}
В отличие от других языков, C++ не имеет каких-либо ограничений в форматировании кода со стороны программистов. Основное правило заключается лишь в том, чтобы использовать только те способы, которые максимально улучшают читабельность и логичность кода.
\end{sloppypar}

\begin{center}
	\textbf{Вот пять основных рекомендаций:}
\end{center}

\begin{flushleft}
	\textbf{\underline{Рекомендация \#1:}} Вместо клавиши \textbf{Tab} используйте \textbf{4 пробел}а. В некоторых IDE по умолчанию стоят тройные пробелы в качестве одного Tab - это тоже нормально (количество пробелов можно легко настроить в соответствующих пунктах меню вашей IDE).
Причиной использования пробелов вместо символов табуляции является то, что если вы откроете свой код в другом редакторе, то он сохранит правильные отступы, в отличие от использования клавиши Tab.
\\
\textbf{\underline{Рекомендация \#2:}} Каждый стейтмент функции должен быть с
соответствующим отступом (Tab или 4 пробела)
\\
\textbf{\underline{Рекомендация \#3:}} Строки не должны быть слишком длинными. 72, 78 или 80 символов – это оптимальный максимум строки.
\\
\textbf{\underline{Рекомендация \#4:}} Если длинная строка разбита на части с помощью определённого оператора (например, << или +), то этот оператор должен находится в конце этой же строки, а не в начале следующей.
\\
\textbf{\underline{Рекомендация \#5:}} Используйте пробелы для улучшения читабельности вашего кода.
\end{flushleft}


\begin{flushleft}
nCost \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ = 57;\\
nPricePerItem \ \ \ \  = 24;\\
nValue \ \ \ \ \ \ \ \ \ \ \ \ \ \ = \ \ 5;\\
nNumberOfItems = \ 17;\\
\end{flushleft}

\begin{sloppypar}
	В uniform инициализации есть дополнительное преимущество: вы не можете присвоить переменной значение, которое не поддерживает её тип данных - компилятор выдаст предупреждение или сообщение об ошибке. Например: int value\{4.5\}; // ошибка: целочисленная переменная не может содержать не целочисленные значения
\end{sloppypar}

\textbf{Правило:} Используйте uniform инициализацию.
\\
В С++ приоритетным является объявлять переменные как можно ближе к их первому использованию
\\
\textbf{Правило:} Объявляйте переменные как можно ближе к их первому использованию.
\\
\begin{center}
	\textbf{Определение целочисленных переменных}
\end{center}
\begin{center}
	\begin{tabular}{ | l | r |}
		\hline
		short int si; & допустимо \\ \hline
		short s; & предпочтительнее \\ \hline
		long int li; & допустимо \\ \hline
		long long int lli; & допустимо \\ \hline
		long long ll; & предпочтительнее \\
		\hline
	\end{tabular}
\end{center}
\begin{center}
	\large\textbf{Переполнение}
\end{center}
\begin{sloppypar}
\textbf{Правило}: Никогда не допускайте возникновения переполнения в ваших программах!
\end{sloppypar}

\begin{center}
	\large\textbf{Магические числа}
\end{center}
Так лучше не делать!
int maxStudents = numClassrooms * 30;
setMax(30);
\\
\begin{sloppypar}
	Избегайте "магических" констант в коде (простые, ничего не значащие цифры). Обозначьте их как const и ссылайтесь на константы, а не на значения:
\end{sloppypar}
 % форматирование кода
// так делать не стоит:
\begin{verbatim}
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 7; j++) {
        if (field[i, j] == 0)
            showError(451);
    }
}
\end{verbatim}
// лучше написать так:
\\
\begin{verbatim}
const int FIELD\_HEIGHT = 3; // высота поля
const int FIELD\_WIDTH = 7; // ширина поля

const int ZERO\_FIELD\_CODE = 451; // код ошибки в случае нулевой ячейки поля

    ...

for (int i = 0; i < FIELD\_HEIGHT; i++) {
    for (int j = 0; j < FIELD\_WIDTH; j++) {
        if (field[i, j] == 0)
            showError(ZERO\_FIELD\_CODE);
    }
}
\end{verbatim}

\begin{sloppypar}
\textbf{Правило:} Старайтесь сократить к минимуму использование магических чисел в ваших программах.
\end{sloppypar}

\begin{center}
	\textbf\large{\textbf{Циклы и условные операторы}}
\end{center}

Циклы позволяют выполнять один код несколько раз, однако существуют различные виды циклов. Для каждой ситуации один цикл может подойти лучше, а другой хуже.

Используйте цикл for, когда количество повторений заранее известно, а цикл while, если число итераций заранее посчитать невозможно:
\begin{verbatim}
// повторять 'size' раз
for (int i = 0; i < size; i++) {
    ...
}

// повторять, пока есть что считывать
Point p;
while (std::cin >> p.x >> p.y) {
    ...
\\}
\end{verbatim}
\begin{sloppypar}
	При использовании операторов цикла (for / while / do-while) или условных операторов(if / else) всегда ставьте фигурные скобки и соответствующие отступы, даже если тело всего оператора состоит всего из одной строки:
\end{sloppypar}
\begin{verbatim}
// так делать не стоит:
if (isWin(gameField)) return;
    else for (int i = 0; i < freeCells.size(); i++) freeCells[i].calcValue();

// лучше написать так:
if (isWin(gameField)) {
    return;
} 
else {
    for (int i = 0; i < freeCells.size(); i++) {
        freeCells[i].calcValue();
    }
}
\end{verbatim}

\begin{center}
	\textbf\large{\textbf{Инкременты}}
\end{center}

\begin{sloppypar}
\textbf{Правило:} Используйте префиксный инкремент и префиксный декремент вместо постфиксного инкремента и постфиксного декремента. Версии префикс не только более производительны, но и ошибок с ними (по статистике) меньше.
\end{sloppypar}
// Так лучше не писать!
\\
int value = add(x, ++x); // здесь 5 + 6 или 6 + 6? Это зависит от компилятора и в каком порядке он будет обрабатывать аргументы функции
\\
\begin{sloppypar}
\textbf{Правило:} Не используйте переменную с побочным эффектом (инкремент) больше одного раза в одном стейтменте.
\end{sloppypar}

\begin{center}
	\textbf\large{\textbf{Тернарный оператор}}
\end{center}

\begin{verbatim}
std::cout << ((x > y) ? x : y);
bool inBigClassroom = true;
const int classSize = inBigClassroom ? 3 : 5;
std::cout << classSize << std::endl;
\end{verbatim}
\begin{sloppypar}
\textbf{Правило:} Используйте условный тернарный оператор ?: только в простых случаях.
\end{sloppypar}
\begin{center}
	\textbf\large{\textbf{Логические операторы и операторы сравнения}}
\end{center}
\textit{\begin{center}
		Не рекомендуется использовать операторы == или != с числами типа с плавающей точкой.
\end{center}}
\begin{sloppypar}
Рассмотрим следующее выражение: value1 || value2 \&\& value3.
Поскольку приоритет логического И выше, то обрабатываться выражение
будет так:
\end{sloppypar}

value1 || (value2 \&\& value3)
А не так:
\\
(value1 || value2) \&\& value3
\\
\begin{sloppypar}
Хорошей практикой является использование круглых скобок с операциями. Это предотвратит ошибки приоритета, увеличит читабельность кода и чётко даст понять компилятору, как следует
обрабатывать выражения. Например, вместо того, чтобы писать:
\\
value1 \&\& value2 || value3 \&\& value4
\\
лучше записать 
\\
(value1 \&\& value2) || (value3 \&\& value4).
\end{sloppypar}
\begin{center}
	\textbf{Законы Де Моргана}
\end{center}
\begin{sloppypar}
Многие программисты совершают ошибку, думая, что !(x \&\& y) - это то
же самое, что и !x \&\& !y. К сожалению, вы не можете "использовать"
логическое НЕ подобным образом.
\end{sloppypar}
Законы Де Моргана гласят, что:
\\ \\
!(x \&\& y) эквивалентно !x || !y
\\
!(x || y) эквивалентно !x \&\& !y
\\
\begin{sloppypar}

Другими словами, логические операторы И и ИЛИ меняются местами! В
некоторых случаях, это даже полезно: улучшает читабельность.
\end{sloppypar}
\begin{center}
\textbf{Заголовочные файлы}
\end{center}
\begin{sloppypar}
Файлы .cpp не являются единственными файлами в проектах. Есть ещё один тип файлов - заголовочные файлы (или ещё "заголовки"), которые имеют расширение .h. Целью заголовочных файлов является удобное хранение набора объявлений объектов для их последующего использования в других программах.
\\ \\
Собственный заголовочный файл (".h") состоит:
\begin{itemize}
\item[*]директивы препроцессора, в частности, header guards, которые предотвращают вызов заголовочного файла больше одного раза с одного и того же файла (об этом детальнее в следующем уроке);
\item[*]содержимое заголовочного файла: набор объявлений.
\end{itemize}
\end{sloppypar}

\begin{sloppypar}
	\textbf{Правило:} Используйте угловые скобки для подключения "системных" заголовочных файлов и двойные кавычки для всего остального (ваших заголовочных файлов).
\end{sloppypar}
\begin{sloppypar}
	\textbf{Правило:} При подключении заголовочных файлов из стандартных библиотек С++, используйте версии без ".h" (если они существуют). Пользовательские заголовочные файлы должны иметь окончание ".h".
\\ \\
Вот несколько советов по написанию собственных заголовочных файлов:
\begin{itemize}
	\item[*]Всегда используйте директивы препроцессора.
	Не определяйте переменные в заголовочных файлах, если это не константы. Заголовочные файлы следует использовать только для объявлений.
	\item[*]Не определяйте функции в заголовочных файлах.
	\item[*]Каждый заголовочный файл должен выполнять свою определённую работу и быть как можно более независимым. Например, вы можете поместить все ваши объявления, связанные с файлом А.cpp в файл A.h, а все ваши объявления, связанные с B.cpp в файл B.h. Таким образом, если вы будете работать только с А.cpp, то вам будет достаточно подключить только A.h и наоборот.
	\item[*]Используйте имена ваших рабочих файлов в качестве имён для ваших заголовочных файлов (например: grades.h работает с grades.cpp).
	\item[*]Не подключайте одни заголовочные файлы из других заголовочных файлов.
	\item[*]Не \#include  файлы .cpp.
\end{itemize}
\end{sloppypar}
\end{document}
