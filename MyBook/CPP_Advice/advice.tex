\documentclass[a4paper,16pt]{report} % Формат А4 и размер шрифта
\usepackage{cmap} % поиск в PDF
\usepackage[T2A]{fontenc} % кодировка
\usepackage[utf8]{inputenc} % кодировка исходного кода
\usepackage[english,russian]{babel} % локализаци и переносы
\usepackage{verbatim} % для длинных коммментариев
\usepackage{array}
%opening
\title{Советы и правила по программированию C++}
\date{\today} % текущая дата
\author{Александр Изотов}

\begin{document}
\maketitle % создаёт титульный лист

%\begin{abstract} % аннотация
%Сделано по книге Ravesli
%\end{abstract}
%\clearpage % новая страница

\textbf{Правило:} Если у вас изначально имеется значение для переменной – используйте инициализацию, вместо присваивания.

\textit{Хорошей практикой считается всегда инициализировать свои переменные. Это будет гарантией того, что ваша переменная всегда имеет одно и то же значение и вы не получите ошибку от компилятора.}

\textbf{Правило:} Убедитесь, что все ваши переменные в программе имеют значения (либо через инициализацию, либо через операцию присваивания).
\\

Функции

\begin{itemize}
	\item[1] Код, который появляется более одного раза в программе, лучше переписать в виде функции. Например, если мы получаем данные от пользователя несколько раз одним и тем же способом, то это отличный вариант для написания отдельной функции.
	\item[2] Код, который используется для сортировки чего-либо, лучше записать в виде отдельной функции. Например, если у нас есть список вещей, которые нужно отсортировать - пишем функцию сортировки, куда передаём несортированный список и откуда получаем отсортированный.
	\item[3] Функция должна выполнять одно (и только одно) задание.
	Когда функция становится слишком большой, сложной или непонятной – её следует разбить на несколько подфункций. Это называется рефакторинг кода.
\end{itemize}


\textbf{Правило:} Имена, которые используются внутри функции (включая
параметры), доступны/видны только внутри этой же функции.

\textbf{Идентификатор} — это имя переменной, функции, класса или другого объекта в C++. Мы можем определять идентификаторы любыми словами/именами. Тем не менее, есть несколько общих правил, которые необходимо соблюдать:
\begin{itemize}
\item[1]Идентификатор не может быть ключевым словом. Ключевые слова зарезервированы.
\item[2]Идентификатор может состоять только из букв (нижнего или верхнего регистра), цифр или символов подчёркивания. Это означает, что все другие символы и пробелы - запрещены.
\item[3]Идентификатор должен начинаться с буквы (нижнего или верхнего регистра). Он не может начинаться с цифры.
\item[4]C++ различает нижний регистр от верхнего. nvalue отличается от nValue и отличается от NVALUE.
\end{itemize}

Если вы работаете с чужим кодом, то хорошей практикой будет придерживаться стиля, в котором написан этот код, даже если он не соответствует рекомендациям выше.

\begin{itemize}
\item[*] не начинайте ваши имена с символа подчёркивания, так как такие имена уже зарезервированы для ОС, библиотеки и/или используются компилятором.
\item[*] используйте в качестве идентификаторов только те имена, которые реально описывают то, чем является объект. Очень характерно для неопытных программистов сокращать имена переменных, дабы сэкономить время при наборе кода или потому что они думают, что всё и так понятно. В большинстве случаев не всё всегда является понятным и очевидным. В идеале переменные нужно называть так, чтобы человек, который первый раз увидел ваш код, понял, как можно скорее, что этот код делает. Через 3 месяца, когда вы будете пересматривать свои программы, вы забудете, как они работают, и будете благодарны самому себе за то, что называли переменные по сути, а не как попало. Чем сложнее код, тем проще и понятнее должны быть идентификаторы.
\end{itemize}

\begin{tabular}{ | l | c | >{\raggedright\arraybackslash}p{5,5cm}| } % настроки столбцов таблицы
	\hline
	int ccount & Плохо & Никто не знает, что такое ccount  \\ \hline % новая строка таблицы
	int customerCount & Хорошо & Теперь понятно, что мы считаем \\ \hline
	int i & Плохо* & В большинстве нетривиальных случаев - плохо, 
	простых примерах - может быть (например, в циклах) \\ \hline
	int index & 50/50 & Хорошо, если очевидно, индексом чего является переменная\\ \hline
	int totalScore & Хорошо & Всё понятно \\ \hline
	int \_count & Плохо & Не начинайте имена переменных с символов подчёркивания\\ \hline
	int count & 50/50 & Хорошо, если очевидно, что мы считаем \\ \hline
	int data & Плохо & Какой тип данных? \\ \hline
	int value1, value2 & 50/50 & Может быть трудно понять разницу между переменными \\ \hline
	int numberOfApples & Хорошо & Всё понятно \\ \hline
	int monstersKilled & Хорошо & Всё понятно \\ \hline
	int int x, y & Плохо* & В большинстве нетривиальных случаев - плохо, 
	в простых примерах - может быть (например, в математических функциях) \\ \hline
\end{tabular}
\newline % начинают новую стоку без начала нового абзаца
\newline
\newline
*Примечание: Можно использовать тривиальные имена для переменных,
которые имеют тривиальное использование (например, для переменных в
цикле, в простых математических функциях и т.д.).
\\ \\
\textbf{Литерал} - это фиксированное значение, которое записывается непосредственно в исходном коде (например: 7 или 3,14159).
\\ \\
Литералы, переменные и функции ещё известны как операнды.
\\ \\
\textbf{Операнды} - это данные, с которыми работает выражение. \textbf{Литералы} имеют фиксированные значения, переменным можно присваивать значения, функции же производят определённые значения (в зависимости от типа возврата, исключение: функции типа void).
\\ \\
\textbf{Операторы.}
Последним пазлом в выражениях являются \textbf{операторы}. С их помощью мы можем объединить операнды для получения нового значения. Например, в выражении "5 \textit{+} 2", \textit{+} является оператором. С помощью + мы объединили операнды 5 и 2 для получения нового значения (7).
\\ \\
В отличие от других языков, C++ не имеет каких-либо ограничений в форматировании кода со стороны программистов. Основное правило заключается лишь в том, чтобы использовать только те способы, которые максимально улучшают читабельность и логичность кода.
\\ \\
\textbf{Вот 6 основных рекомендаций:}
\\ 
\underline{Рекомендация No1:} Вместо клавиши \textbf{Tab} используйте \textbf{4 пробел}а. В некоторых IDE по умолчанию стоят тройные пробелы в качестве одного Tab - это тоже нормально (количество пробелов можно легко настроить в соответствующих пунктах меню вашей IDE).
Причиной использования пробелов вместо символов табуляции является то, что если вы откроете свой код в другом редакторе, то он сохранит правильные отступы, в отличие от использования клавиши Tab.
\\
\underline{Рекомендация No2:} Каждый стейтмент функции должен быть с
соответствующим отступом (Tab или 4 пробела)
\\
\underline{Рекомендация No3:} Строки не должны быть слишком длинными. 72, 78 или 80 символов – это оптимальный максимум строки.
\\
\underline{Рекомендация No4:} Если длинная строка разбита на части с помощью определённого оператора (например, << или +), то этот оператор должен находится в конце этой же строки, а не в начале следующей.
\\
\underline{Рекомендация No6:} Используйте пробелы для улучшения читабельности вашего кода.
\\
nCost \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ = 57;\\
nPricePerItem \ \ \ \  = 24;\\
nValue \ \ \ \ \ \ \ \ \ \ \ \ \ \ = \ \ 5;\\
nNumberOfItems = \ 17;\\
\\
\textbf{Правило:} Используйте угловые скобки для подключения
"системных" заголовочных файлов и двойные кавычки для всего остального (ваших заголовочных файлов).
\\
\textbf{Правило:} При подключении заголовочных файлов из стандартных библиотек С++, используйте версии без ".h" (если они существуют). Пользовательские заголовочные файлы должны иметь окончание ".h".
\\
Вот несколько советов по написанию собственных заголовочных файлов:
\begin{itemize}
\item[*]Всегда используйте директивы препроцессора.
Не определяйте переменные в заголовочных файлах, если это не константы. Заголовочные файлы следует использовать только для объявлений.
\item[*]Не определяйте функции в заголовочных файлах.
\item[*]Каждый заголовочный файл должен выполнять свою определённую работу и быть как можно более независимым. Например, вы можете поместить все ваши объявления, связанные с файлом А.cpp в файл A.h, а все ваши объявления, связанные с B.cpp в файл B.h. Таким образом, если вы будете работать только с А.cpp, то вам будет достаточно подключить только A.h и наоборот.
\item[*]Используйте имена ваших рабочих файлов в качестве имён для ваших заголовочных файлов (например: grades.h работает с grades.cpp).
\item[*]Не подключайте одни заголовочные файлы из других заголовочных файлов.
\item[*]Не \#include  файлы .cpp.
\end{itemize}
\begin{sloppypar}В uniform инициализации есть дополнительное преимущество: вы не можете присвоить переменной значение, которое не поддерживает её тип данных - компилятор выдаст предупреждение или сообщение об
ошибке. Например:
int value\{4.5\}; // ошибка: целочисленная переменная не может содержать не целочисленные значения
\end{sloppypar}

\textbf{Правило:} Используйте uniform инициализацию.
\\
В С++ приоритетным является объявлять переменные как можно ближе к их первому использованию
\\
\textbf{Правило:} Объявляйте переменные как можно ближе к их первому использованию.
\\
\begin{center}
Определение целочисленных переменных
\end{center}
\begin{center}
	\begin{tabular}{ | l | r |}
		\hline
		short int si; & допустимо \\ \hline
		short s; & предпочтительнее \\ \hline
		long int li; & допустимо \\ \hline
		long long int lli; & допустимо \\ \hline
		long long ll; & предпочтительнее \\
		\hline
	\end{tabular}
\end{center}
\begin{center}
Переполнение
\end{center}
\textbf{Правило}: Никогда не допускайте возникновения переполнения в ваших программах!
\end{document}
